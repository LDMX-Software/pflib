# Set the minimum version of CMake that's required
cmake_minimum_required(VERSION 3.12)

# Set the project name
project(pflib
	DESCRIPTION "Pretty fine HGCROC configuration library."
	LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 20)

find_package(Git)
add_custom_target(git_version
  ${CMAKE_COMMAND} -D SRC=${CMAKE_SOURCE_DIR}/src/pflib/version/cmake_version.h.in
                   -D DST=${CMAKE_BINARY_DIR}/include/version/cmake_version.h
                   -D GIT_EXECUTABLE=${GIT_EXECUTABLE}
                   -P ${CMAKE_SOURCE_DIR}/GenerateVersionHeader.cmake
)
add_library(version SHARED src/pflib/version/Version.cxx)
target_include_directories(version PUBLIC
  "$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>"
  "$<INSTALL_INTERFACE:include>")
target_include_directories(version PUBLIC
  "$<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include/version/>"
  "$<INSTALL_INTERFACE:include>")
add_dependencies(version git_version)

# YAML->register value "compiler"
#   optional, build it if we can find the yaml parser we use
find_package(yaml-cpp REQUIRED)
message(STATUS "Found yaml-cpp ${yaml-cpp_VERSION}")
if (NOT TARGET yaml-cpp::yaml-cpp)
  add_library(yaml-cpp::yaml-cpp ALIAS yaml-cpp)
endif()

# Boost for CRC calculator, Test, and Logging
find_package(Boost COMPONENTS log unit_test_framework REQUIRED)

# Generate the register map headers for the different supported ROCs
#  "v2" rocs were manually written so we just copy them into the correct spot
#  "v3+" rocs have their headers generated by a python script
# The extra CMake nonsense is setup so that the header generation only happens
# if necessary (new build or timestamp of source files is newer than generated files).
set(reg_map_src "${PROJECT_SOURCE_DIR}/register_maps/sipm_rocv2.h")
set(reg_map_header "include/register_maps/sipm_rocv2.h")
add_custom_command(
  OUTPUT ${reg_map_header}
  COMMAND mkdir -p ${CMAKE_CURRENT_BINARY_DIR}/include/register_maps
  COMMAND cp ${reg_map_src} ${CMAKE_CURRENT_BINARY_DIR}/${reg_map_header}
  DEPENDS ${reg_map_src}
  COMMENT "Copying legacy C++ parameter LUTs from ${reg_map_src}"
  VERBATIM
)
add_custom_target(sipm_rocv2 DEPENDS ${reg_map_header})
list(APPEND generate_headers sipm_rocv2)
foreach(roc "si_roc" "si_rocv3b" "sipm_rocv3" "sipm_rocv3b")
  set(reg_map_src "${PROJECT_SOURCE_DIR}/register_maps/${roc}_regmap.yaml")
  set(reg_map_header "include/register_maps/${roc}.h")
  add_custom_command(
    OUTPUT ${reg_map_header}
    COMMAND python3 ${PROJECT_SOURCE_DIR}/register_maps/byte-pair-to-page-reg.py
      ${reg_map_src} ${CMAKE_CURRENT_BINARY_DIR}/${reg_map_header} --no-intermediate-yaml
    DEPENDS ${reg_map_src} ${PROJECT_SOURCE_DIR}/register_maps/byte-pair-to-page-reg.py
    COMMENT "Generating C++ parameter LUTs from ${reg_map_src}"
    VERBATIM
  )
  add_custom_target(${roc} DEPENDS ${reg_map_header})
  list(APPEND generate_headers "${roc}")
endforeach()

add_custom_command(
  OUTPUT "include/register_maps/direct_access.h"
  COMMAND python3
  ${PROJECT_SOURCE_DIR}/register_maps/write-direct-access-header.py
  ${PROJECT_SOURCE_DIR}/register_maps/si_roc_directaccess_regmap.yaml
  ${CMAKE_CURRENT_BINARY_DIR}/include/register_maps/direct_access.h
  DEPENDS
  ${PROJECT_SOURCE_DIR}/register_maps/write-direct-access-header.py
  ${PROJECT_SOURCE_DIR}/register_maps/si_roc_directaccess_regmap.yaml
  COMMENT "Generating C++ Direct Access LUT from register_maps/si_roc_directaccess_regmap.yaml"
  VERBATIM
)
add_custom_target(direct_access DEPENDS include/register_maps/direct_access.h)
# do NOT include the direct_access header in the list of register maps to be included in the unifying header
# direct access "compilation" is simpler and is done directly within the ROC class and not
# within the Compiler

add_custom_command(
  OUTPUT "include/register_maps/lpgbt.h"
  COMMAND python3
  ${PROJECT_SOURCE_DIR}/register_maps/lpgbt-to-code.py
  ${PROJECT_SOURCE_DIR}/register_maps/lpgbt_regmap.yaml
  ${CMAKE_CURRENT_BINARY_DIR}/include/register_maps/lpgbt.h
  DEPENDS
  ${PROJECT_SOURCE_DIR}/register_maps/lpgbt-to-code.py
  ${PROJECT_SOURCE_DIR}/register_maps/lpgbt_regmap.yaml
  COMMENT "Generating C++ lpGBT register LUT from register_maps/lpgbt_regmap.yaml"
  VERBATIM
)
add_custom_target(lpgbt_regmap DEPENDS include/register_maps/lpgbt.h)

add_custom_command(
  OUTPUT include/register_maps/register_maps.h
  COMMAND python3 ${PROJECT_SOURCE_DIR}/register_maps/write-unifying-header.py
    ${generate_headers} --output include/register_maps/register_maps.h
  COMMAND cp ${PROJECT_SOURCE_DIR}/register_maps/register_maps_types.h include/register_maps/
  DEPENDS ${generate_headers} ${PROJECT_SOURCE_DIR}/register_maps/register_maps_types.h
  COMMENT "Writing unifying header for parameter LUTs"
  VERBATIM
)
add_custom_target(register_maps_header DEPENDS include/register_maps/register_maps.h)

add_library(packing SHARED
  src/pflib/packing/FileReader.cxx
  src/pflib/packing/BufferReader.cxx
  src/pflib/packing/Sample.cxx
  src/pflib/packing/DAQLinkFrame.cxx
  src/pflib/packing/TriggerLinkFrame.cxx
  src/pflib/packing/SingleROCEventPacket.cxx
)
target_include_directories(packing PUBLIC 
  "$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>"
  "$<INSTALL_INTERFACE:include>")


# Build the pf library
#
#  src/pflib/Bias.cxx
#  src/pflib/FastControl.cxx
  
add_library(pflib SHARED 
  src/pflib/I2C_Linux.cxx
  src/pflib/ROC.cxx
  src/pflib/Compile.cxx
  src/pflib/Logging.cxx
  src/pflib/Hcal.cxx
  src/pflib/Target.cxx
  src/pflib/GPIO.cxx
  src/pflib/Elinks.cxx
  src/pflib/DecodeAndWrite.cxx
  src/pflib/WriteToBinaryFile.cxx
  src/pflib/lpGBT.cxx
  src/pflib/lpgbt/lpGBT_ConfigTransport_I2C.cxx
  src/pflib/lpgbt/lpGBT_Registers.cxx
  src/pflib/lpgbt/lpGBT_Utility.cxx
  src/pflib/TargetFiberless.cxx
  src/pflib/GPIO_HcalHGCROCZCU.cxx
  src/pflib/FastControlCMS_MMap.cxx
  src/pflib/ECOND_Formatter.cxx
  src/pflib/utility.cxx
  src/pflib/zcu/UIO.cxx
  src/pflib/zcu/Elinks_zcu.cxx
)
target_include_directories(pflib PUBLIC 
  "$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>"
  "$<INSTALL_INTERFACE:include>")
target_include_directories(pflib PUBLIC
  "$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include>"
  "$<INSTALL_INTERFACE:include>")
target_link_libraries(pflib PUBLIC yaml-cpp::yaml-cpp packing Boost::log version)
add_dependencies(pflib register_maps_header direct_access lpgbt_regmap)

add_library(menu SHARED
  src/pflib/menu/Menu.cc
  src/pflib/menu/Rcfile.cc
)
target_link_libraries(menu PUBLIC readline pflib)
target_include_directories(menu PUBLIC 
  "$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>"
  "$<INSTALL_INTERFACE:include>")

add_executable(
  test-pflib
  test/main.cxx
  test/compile.cxx
  test/decoding.cxx
  test/utility.cxx
)
target_link_libraries(test-pflib PRIVATE Boost::unit_test_framework pflib packing)

add_executable(
  test-pflib-on-zcu
  test/on_zcu/main.cxx
  test/on_zcu/hgcroc_connection.cxx
  test/on_zcu/test_parameters.cxx
  test/on_zcu/elinks_aligned.cxx
)
target_link_libraries(test-pflib-on-zcu PRIVATE Boost::unit_test_framework pflib packing)

add_executable(pftool app/tool/main.cxx app/tool/expert.cxx)
target_link_libraries(pftool PRIVATE pflib menu)

add_executable(pflpgbt app/lpgbt/main.cxx app/lpgbt/lpgbt_mezz_tester.cc)
target_link_libraries(pflpgbt PRIVATE pflib menu)

# don't install test-menu executable! just for Menu developments
add_executable(test-menu test/test_menu.cxx)
target_link_libraries(test-menu PRIVATE pflib menu)

add_executable(pfdecoder app/pfdecoder.cxx)
target_link_libraries(pfdecoder PRIVATE pflib)

add_executable(pfcompile app/pfcompile.cxx)
target_link_libraries(pfcompile pflib)

add_executable(pfdecompile app/pfdecompile.cxx)
target_link_libraries(pfdecompile pflib)

add_executable(pfdefaults app/pfdefaults.cxx)
target_link_libraries(pfdefaults pflib)

set_target_properties(pflib packing PROPERTIES PREFIX "libpflib_")
install(TARGETS pflib packing version pftool pfdecoder pfdecompile pfcompile pfdefaults
  EXPORT pflibTargets 
  LIBRARY DESTINATION lib
  ARCHIVE DESTINATION lib
  RUNTIME DESTINATION bin
  INCLUDES DESTINATION include
  )
install(DIRECTORY include/ DESTINATION include/ FILES_MATCHING PATTERN "*.h")
install(EXPORT pflibTargets
  FILE pflibTargets.cmake
  NAMESPACE pflib::
  DESTINATION lib/cmake/pflib
  )
