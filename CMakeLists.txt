# Set the minimum version of CMake that's required
cmake_minimum_required(VERSION 3.12)

execute_process(
  COMMAND git describe --tags
  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
  RESULT_VARIABLE git_rc
  OUTPUT_VARIABLE git_describe)
if (NOT ${git_rc} EQUAL 0)
  set(pflib_vers "0.0")
  message(WARNING "System cannot deduce git tag, this pflib built is un-versioned.")
else()
  string(REGEX REPLACE "\n$" "" git_describe ${git_describe})
  set(pflib_vers ${git_describe})
  string(REGEX REPLACE "^v" "" pflib_vers ${pflib_vers})
  string(REGEX REPLACE "-.*$" "" pflib_vers ${pflib_vers})
endif()
message(STATUS "Deduced pflib version ${pflib_vers}")

# Set the project name
project(pflib
	VERSION ${pflib_vers}
	DESCRIPTION "Pretty fine HGCROC configuration library."
	LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 20)


# YAML->register value "compiler"
#   optional, build it if we can find the yaml parser we use
find_package(yaml-cpp REQUIRED)
message(STATUS "Found yaml-cpp ${yaml-cpp_VERSION}")

# Generate the register map headers for the different supported ROCs
#  "v2" rocs were manually written so we just copy them into the correct spot
#  "v3+" rocs have their headers generated by a python script
# The extra CMake nonsense is setup so that the header generation only happens
# if necessary (new build or timestamp of source files is newer than generated files).
set(reg_map_src "${PROJECT_SOURCE_DIR}/register_maps/sipm_rocv2.h")
set(reg_map_header "include/register_maps/sipm_rocv2.h")
add_custom_command(
  OUTPUT ${reg_map_header}
  COMMAND mkdir -p ${CMAKE_CURRENT_BINARY_DIR}/include/register_maps
  COMMAND cp ${reg_map_src} ${CMAKE_CURRENT_BINARY_DIR}/${reg_map_header}
  DEPENDS ${reg_map_src}
  COMMENT "Copying legacy C++ parameter LUTs from ${reg_map_src}"
  VERBATIM
)
add_custom_target(sipm_rocv2 DEPENDS ${reg_map_header})
list(APPEND generate_headers sipm_rocv2)
foreach(roc "si_roc" "si_rocv3b" "sipm_rocv3" "sipm_rocv3b")
  set(reg_map_src "${PROJECT_SOURCE_DIR}/register_maps/${roc}_regmap.yaml")
  set(reg_map_header "include/register_maps/${roc}.h")
  add_custom_command(
    OUTPUT ${reg_map_header}
    COMMAND python3 ${PROJECT_SOURCE_DIR}/register_maps/byte-pair-to-page-reg.py
      ${reg_map_src} ${CMAKE_CURRENT_BINARY_DIR}/${reg_map_header} --no-intermediate-yaml
    DEPENDS ${reg_map_src} ${PROJECT_SOURCE_DIR}/register_maps/byte-pair-to-page-reg.py
    COMMENT "Generating C++ parameter LUTs from ${reg_map_src}"
    VERBATIM
  )
  add_custom_target(${roc} DEPENDS ${reg_map_header})
  list(APPEND generate_headers "${roc}")
endforeach()

add_custom_command(
  OUTPUT "include/register_maps/direct_access.h"
  COMMAND python3
  ${PROJECT_SOURCE_DIR}/register_maps/write-direct-access-header.py
  ${PROJECT_SOURCE_DIR}/register_maps/si_roc_directaccess_regmap.yaml
  ${CMAKE_CURRENT_BINARY_DIR}/include/register_maps/direct_access.h
  DEPENDS
  ${PROJECT_SOURCE_DIR}/register_maps/write-direct-access-header.py
  ${PROJECT_SOURCE_DIR}/register_maps/si_roc_directaccess_regmap.yaml
  COMMENT "Generating C++ Direct Access LUT from register_maps/si_roc_directaccess_regmap.yaml"
  VERBATIM
)
add_custom_target(direct_access DEPENDS include/register_maps/direct_access.h)
# do NOT include the direct_access header in the list of register maps to be included in the unifying header
# direct access "compilation" is simpler and is done directly within the ROC class and not
# within the Compiler

add_custom_command(
  OUTPUT include/register_maps/register_maps.h
  COMMAND python3 ${PROJECT_SOURCE_DIR}/register_maps/write-unifying-header.py
    ${generate_headers} --output include/register_maps/register_maps.h
  COMMAND cp ${PROJECT_SOURCE_DIR}/register_maps/register_maps_types.h include/register_maps/
  DEPENDS ${generate_headers} ${PROJECT_SOURCE_DIR}/register_maps/register_maps_types.h
  COMMENT "Writing unifying header for parameter LUTs"
  VERBATIM
)
add_custom_target(register_maps_header DEPENDS include/register_maps/register_maps.h)

configure_file(include/pflib/Version.h.in include/pflib/Version.h)

# Build the pf library
#
#  src/pflib/Bias.cxx
#  src/pflib/FastControl.cxx
  
add_library(pflib SHARED 
  src/pflib/I2C_Linux.cxx
  src/pflib/ROC.cxx
  src/pflib/Compile.cxx
  src/pflib/Hcal.cxx
  src/pflib/Target.cxx
  src/pflib/GPIO.cxx
  src/pflib/Elinks.cxx
  src/pflib/TargetFiberless.cxx
  src/pflib/GPIO_HcalHGCROCZCU.cxx
  src/pflib/FastControlCMS_MMap.cxx
  src/pflib/Version.cxx
  src/pflib/zcu/UIO.cxx
  src/pflib/zcu/Elinks_zcu.cxx
)
target_include_directories(pflib PUBLIC 
  "$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>"
  "$<INSTALL_INTERFACE:include>")
target_include_directories(pflib PUBLIC
  "$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include>"
  "$<INSTALL_INTERFACE:include>")
target_link_libraries(pflib PUBLIC yaml-cpp)
add_dependencies(pflib register_maps_header direct_access)

add_executable(pftool app/tool/pftool.cc app/tool/Menu.cc app/tool/Rcfile.cc)
target_link_libraries(pftool PRIVATE pflib readline)

# don't install test-menu executable! just for Menu developments
add_executable(test-menu app/tool/test_menu.cxx app/tool/Menu.cc)
target_link_libraries(test-menu PRIVATE pflib readline)

add_executable(pfdecoder app/pfdecoder.cc)

add_executable(pfcompile app/pfcompile.cxx)
target_link_libraries(pfcompile pflib)

add_executable(pfdecompile app/pfdecompile.cxx)
target_link_libraries(pfdecompile pflib)

add_executable(pfdefaults app/pfdefaults.cxx)
target_link_libraries(pfdefaults pflib)

# Now determine which method of interaction to use for communicating with the polarfire
#   - if neither are available, fatal cmake error - this library is useless without one

# Rogue
if (DEFINED ENV{ROGUE_DIR})
   set(Rogue_DIR $ENV{ROGUE_DIR}/lib)
else()
   set(Rogue_DIR ${CMAKE_PREFIX_PATH}/lib)
endif()
# issues its own "found Rogue version ___" message
find_package(Rogue CONFIG)

if (Rogue_FOUND)
  # the libraries parameter includes the PUBLIC keyword annoyingly
  list(REMOVE_ITEM ROGUE_LIBRARIES "PUBLIC")
  # define source files this submodule uses
  add_library(rogue SHARED src/pflib/rogue/RogueWishboneInterface.cxx)
  # attach rogue as a dependency
  target_link_libraries(rogue PUBLIC pflib ${ROGUE_LIBRARIES})
  target_include_directories(rogue PUBLIC ${ROGUE_INCLUDE_DIRS})
  # let pftool know that rogue is available
  target_compile_definitions(pftool PRIVATE PFTOOL_ROGUE=1)
  # link submodule lib to pftool
  target_link_libraries(pftool PRIVATE rogue)
  list(APPEND comm_libs rogue)
else()
  message(STATUS "Unable to find Rogue, will not compile rogue submodule of pflib.")
endif()

#if (NOT Rogue_FOUND AND NOT Uhal_FOUND)
#  message(WARNING "Neither Rogue or Uhal were found. At least one is necessary for a functional polarfire interaction library.")
#endif()

set_target_properties(pflib ${comm_libs} PROPERTIES PREFIX "libpflib_")

install(TARGETS pflib ${comm_libs} pftool pfdecoder pfdecompile pfcompile pfdefaults
  EXPORT pflibTargets 
  LIBRARY DESTINATION lib
  ARCHIVE DESTINATION lib
  RUNTIME DESTINATION bin
  INCLUDES DESTINATION include
  )
install(DIRECTORY include/ DESTINATION include/ FILES_MATCHING PATTERN "*.h")
install(EXPORT pflibTargets
  FILE pflibTargets.cmake
  NAMESPACE pflib::
  DESTINATION lib/cmake/pflib
  )

include(CMakePackageConfigHelpers)
configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in
  "${CMAKE_CURRENT_BINARY_DIR}/pflibConfig.cmake"
  INSTALL_DESTINATION lib/cmake/pflib
  )
write_basic_package_version_file("${CMAKE_CURRENT_BINARY_DIR}/pflibConfigVersion.cmake"
  COMPATIBILITY AnyNewerVersion)
install(FILES
  "${CMAKE_CURRENT_BINARY_DIR}/pflibConfig.cmake"
  "${CMAKE_CURRENT_BINARY_DIR}/pflibConfigVersion.cmake"
  DESTINATION lib/cmake/pflib
  )
