/**
 * Print the defaults for the HGC ROC stored in pflib
 */

#include <iostream>
#include <algorithm>
#include <iomanip>
#include <fstream>
#include <strings.h>

#include <yaml-cpp/yaml.h>

#include "pflib/Exception.h"
#include "pflib/Compile.h"

static void usage() {
  std::cout <<
    "\n"
    " USAGE:\n"
    "  pfdefaults [options] [output_file]\n"
    "\n"
    " OPTIONS:\n"
    "  -h,--help     : Print this help and exit\n"
    "  --def-exlcude : Exclude all pages by default\n"
    "                  (without this parameter, include all pages by default)\n"
    "  -e,--exclude  : Page name (or substring of page name) to exclude from printing\n"
    "                  Provide more than once to exclude mutliple pages.\n"
    "  -i,--include  : Page name (or substring of page name) to include for printing\n"
    "                  Provide more than once to include mutliple pages.\n"
    "  output_file   : Name of file to write YAML to (std::cout if no file given)\n"
    "\n"
    "  The exclude/include rules are processed in order meaning that the last matching\n"
    "  rule is what is used to decide on if a page should be printed or not.\n"
    << std::endl;
}

int main(int argc, char *argv[]) {
  bool default_include{true};
  std::vector<std::pair<std::string,bool>> eirules;
  std::string output_filename;
  std::stringstream cmd;
  cmd << argv[0];
  for (int i_arg{1}; i_arg < argc; i_arg++) {
    std::string arg{argv[i_arg]};
    cmd << " " << arg;
    if (arg[0] == '-') {
      // option
      if (arg == "--help" or arg == "-h") {
        usage();
        return 0;
      } else if (arg == "--exclude" or arg == "-e" or arg == "--include" or arg == "-i") {
        if (i_arg+1 == argc or argv[i_arg+1][0] == '-') {
          std::cerr << "ERROR: The " << arg 
            << " parameter requires are argument after it." << std::endl;
          return 1;
        }
        i_arg++;
        cmd << " " << argv[i_arg];
        eirules.emplace_back(argv[i_arg],arg.find("i") != std::string::npos);
      } else if (arg == "--def-exclude") {
        default_include = false;
      } else {
        std::cerr << "ERROR: " << arg << " not a recognized argument." << std::endl;
        return 1;
      }
    } else {
      // positional ==> settings file
      if (not output_filename.empty()) {
        std::cerr << "ERROR: We only write defaults to one file at a time." << std::endl;
        return 1;
      }
      output_filename = arg;
    }
  }

  std::map<std::string,std::map<std::string,int>> parameters = pflib::defaults();

  YAML::Emitter out;
  out << YAML::Comment("These YAML settings were generated by "+cmd.str());
  out << YAML::BeginMap;
  for (const auto& page : parameters) {
    // search through list BACKWARDS, meaning the last rule that applies will be the decision
    auto rule_it{std::find_if(eirules.rbegin(), eirules.rend(),
        [&](const auto& rule_pair) {
          return (strncasecmp(page.first.c_str(), rule_pair.first.c_str(), rule_pair.first.size()) == 0);
        })};
    bool include{default_include};
    if (rule_it != eirules.rend()) include = rule_it->second;
    if (include) {
      out << YAML::Key << page.first;
      out << YAML::Value << YAML::BeginMap;
      for (const auto& param : page.second) {
        out << YAML::Key << param.first << YAML::Value << param.second;
      }
      out << YAML::EndMap;
    }
  }
  out << YAML::EndMap;

  if (output_filename.empty()) {
    std::cout << out.c_str() << std::endl;
  } else {
    std::ofstream of(output_filename);
    if (not of.is_open()) {
      std::cerr << "ERROR: Unable to open output file " << output_filename << std::endl;
      return 2;
    }
    of << out.c_str() << std::endl;
  }

  return 0;
}
