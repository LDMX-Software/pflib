/**
 * "compiler" translating YAML HGCROC settings files
 * into a CSV file that contains registers and their values
 * defined by the settings in the YAML.
 *
 * Only compiled and installed if yaml-cpp is found by CMake.
 */

#include <iostream>
#include <iomanip>
#include <fstream>

#include "pflib/Exception.h"
#include "pflib/Compile.h"
#include "pflib/Version.h"

static void usage() {
  std::cout <<
    "\n"
    " USAGE:\n"
    "  pfcompile [options] setting_file [setting_file1 [setting_file2 ...]]\n"
    "\n"
    " OPTIONS:\n"
    "  -v,--version  : Print pflib version\n"
    "  -h,--help     : Print this help and exit\n"
    "  -r,--roc      : Define the ROC type_version that should be used for compilation\n"
    "                  By default, we use the sipm_rocv3b register mapping.\n"
    "  --no-defaults : Don't apply the defaults copied from the documentation before anything else\n"
    "  --output, -o  : Define the output file.\n"
    "                  By default, the output file is the last setting file with the extension\n"
    "                  changed to 'csv'\n"
    << std::endl;
}

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage();
    return 1;
  }

  bool prepend_defaults = true;
  std::vector<std::string> setting_files;
  std::string roc_type_version{"sipm_rocv3b"};
  std::string output_filename;
  for (int i_arg{1}; i_arg < argc; i_arg++) {
    std::string arg{argv[i_arg]};
    if (arg[0] == '-') {
      // option
      if (arg == "--no-defaults") {
        prepend_defaults = false;
      } else if (arg == "--help" or arg == "-h") {
        usage();
        return 0;
      } else if (arg == "--version" or arg == "-v") {
        print_version();
        return 0;
      } else if (arg == "--roc" or arg == "-r") {
        if (i_arg+1 == argc or argv[i_arg+1][0] == '-') {
          std::cerr << "ERROR: The " << arg << " parameter requires are argument after it." << std::endl;
          return 1;
        }
        i_arg++;
        roc_type_version = argv[i_arg];
      } else if (arg == "--output" or arg == "-o") {
        if (i_arg+1 == argc or argv[i_arg+1][0] == '-') {
          std::cerr << "ERROR: The " << arg << " parameter requires are argument after it." << std::endl;
          return 1;
        }
        i_arg++;
        output_filename = argv[i_arg];
      } else {
        std::cerr << "ERROR: " << arg << " not a recognized argument." << std::endl;
        return 1;
      }
    } else {
      // positional ==> settings file
      setting_files.push_back(arg);
    }
  }

  if (setting_files.empty()) {
    std::cerr << "ERROR: We need at least one settings YAML file to compile." << std::endl;
    return 2;
  }

  if (output_filename.empty()) {
    // deduce a output file name by replace the 'yaml' extenion
    // of the LAST settings file input with 'csv'
    output_filename = setting_files.at(setting_files.size()-1);
    // strip extension
    output_filename = output_filename.substr(0,output_filename.find_last_of('.'));
    // add csv extension
    output_filename += ".csv";
  }

  // try to open file before compilation to make sure we have access
  std::ofstream f{output_filename};
  if (not f.is_open()) {
    std::cerr << "ERROR: Unable to open output file " << output_filename << std::endl;
    return 3;
  }

  std::map<int,std::map<int,uint8_t>> settings;
  try {
    // compilation checks parameter/page names
    settings = pflib::Compiler::get(roc_type_version).compile(setting_files, prepend_defaults);
  } catch (const pflib::Exception& e) {
    std::cerr << "ERROR: " << "[" << e.name() << "] "
      << e.message() << std::endl;
    return -1;
  }

  f <<
    "# This register settings file was generated by pfcompile\n"
    "#    The columns are: page, register, value (in hex)\n";
  for (const auto& page : settings) {
    int i_page = page.first;
    for (const auto& reg : page.second) {
      int i_reg = reg.first;
      uint8_t val = reg.second;
      f << i_page << ',' << i_reg << ',' 
        << "0x" << std::setfill('0') << std::setw(2) 
        << std::hex << static_cast<int>(val) << std::dec
        << '\n';
    }
  }

  f.flush();

  return 0;
}
